---
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r, echo=FALSE}
options(tibble.print_min = 5)
```


# Question 2 {#q2}

**Question:**

_Can the three yield curve factors explain the time-series variation in spot rates? Regress $y_t(1)$ on a constant and $X_t$ and comment on the regression statistics. Perform the same analysis for $y_t(5)$ and $y_t(10)$._

In this section, the following packages are used:

```{r, message=FALSE, warning=FALSE}
library(readr)
library(dplyr)
library(tidyr)
library(ratekit)
library(ggplot2)
library(broom)
library(purrr)
library(furrr)
library(rsample)
library(tibbletime)
library(forcats)
```

We will need the data for the $y_t(1)$, $y_t(5)$, and $y_t(10)$ spot rates along
with the yield curve factors. These have already been calculated in the scripts referenced in \@ref(spot-rates) and \@ref(yield-curve-factors) so we can just load them in.

```{r}
rates    <- read_rds("data/computed/rates.rds")
yield_curve_factors <- read_rds("data/computed/yield_curve_factors.rds")
n <- c("1", "5", "10")

spot_rates_q2 <- rates

spot_rates_q2
```

## Regression

Using the concept of multiple models from the book, [`R 4 Data Science`](http://r4ds.had.co.nz/many-models.html), implementing these regressions in R is incredibly straightforward. First, we shard the series into separate data frames. 

```{r}
nested_spot <- spot_rates_q2 %>%
  # Add on the curve factors
  left_join(yield_curve_factors, by = "date") %>%
  
  # Group by maturity and nest
  group_by(maturity) %>%
  select(-maturity_nm) %>%
  nest()
```

Then we apply the linear model to each shard. The far right column, `model` contains
the results of the linear models. I went ahead and calculated models for every
maturity because I am going to use them in some exploration later.

```{r}
nested_models <- nested_spot %>%
  mutate(model = map(data, ~ lm(spot_rate ~ level + slope + curvature, data = .x)))

nested_models
```

## One Year Spot Rate 

As you can see below, all estimates for the 1 year spot rate model are highly significant, 
and the Adjusted $R^2$ is nearing 100%, suggesting that the model can explain
essentially all of the variation in the spot rate.

```{r, echo=FALSE}
model_1_yr <- nested_models %>%
  filter(maturity == 1) %>%
  pluck(list("model", 1))

model_1_yr %>%
  tidy() %>%
  rename(Term = term, Estimate = estimate, `Standard Error` = std.error, `Statistic` = statistic, `P-Value` = p.value) %>%
  knitr::kable(digits = 15)
```

```{r, echo=FALSE}
model_1_yr %>%
  glance() %>%
  select(`R Squared` = r.squared, `R Squared Adj` = adj.r.squared, `Residual Std Error` = sigma) %>%
  knitr::kable()
```

A chart of the realized VS predicted time series confirms how well the variation
is explained. It is important to remember that this model is not predicting 
future rates, and is simply used to gather intuition about past rates.

```{r}
plot_rates_vs_predictions <- function(.rates, .model, .maturity) {
  .rates %>%
    filter(maturity == .maturity) %>%
    rename(Realized = spot_rate) %>%
    mutate(Predicted = predict(.model)) %>%
    gather("Realized/Predicted", "Spot Rate", Realized, Predicted) %>%
    ggplot(aes(x = date, y = `Spot Rate`, color = `Realized/Predicted`)) +
    geom_line() +
    theme_minimal() +
    scale_color_brewer(palette = "Dark2") +
    labs(x = "")
}
```


```{r, fig.width=10, cache=TRUE, warning=FALSE, fig.cap="One year spot rate: In sample predictions VS realized", echo=FALSE}
plot_rates_vs_predictions(spot_rates_q2, model_1_yr, 1)
```


## Five Year Spot Rate 

The model for the 5 year rate is similar to the 1 year rate in terms of explanatory power.

```{r, echo=FALSE}
model_5_yr <- nested_models %>%
  filter(maturity == 5) %>%
  pluck(list("model", 1))

model_5_yr %>%
  tidy() %>%
  rename(Term = term, Estimate = estimate, `Standard Error` = std.error, `Statistic` = statistic, `P-Value` = p.value) %>%
  knitr::kable(digits = 15)
```

```{r, echo=FALSE}
model_5_yr %>%
  glance() %>%
  select(`R Squared` = r.squared, `R Squared Adj` = adj.r.squared, `Residual Std Error` = sigma) %>%
  knitr::kable()
```

<br> </br>

```{r, fig.width=10, cache=TRUE, warning=FALSE, fig.cap="Five year spot rate: In sample predictions VS realized", echo=FALSE}
plot_rates_vs_predictions(spot_rates_q2, model_5_yr, 5)
```

## Ten Year Spot Rate 

And again, the 10 year model performs well too.

```{r, echo=FALSE}
model_10_yr <- nested_models %>%
  filter(maturity == 10) %>%
  pluck(list("model", 1))

model_10_yr %>%
  tidy() %>%
  rename(Term = term, Estimate = estimate, `Standard Error` = std.error, `Statistic` = statistic, `P-Value` = p.value) %>%
  knitr::kable(digits = 15)
```

```{r, echo=FALSE}
model_10_yr %>%
  glance() %>%
  select(`R Squared` = r.squared, `R Squared Adj` = adj.r.squared, `Residual Std Error` = sigma) %>%
  knitr::kable()
```

<br> </br>

```{r, fig.width=10, cache=TRUE, warning=FALSE, fig.cap="Ten year spot rate: In sample predictions VS realized", echo=FALSE}
plot_rates_vs_predictions(spot_rates_q2, model_10_yr, 10)
```

## Decomposing the Spot Curve

Although not specifically asked for, I thought it might be interesting to 
decompose and plot the spot curve at a few particular points in time. We will
need a few functions to do so. The functions essentially allow us to abstract 
away all the work so that we can just check out the spot rate graph at any date.

```{r}
extract_rates <- function(.rates, .date) {
  .rates %>%
    as_tbl_time(date) %>%
    group_by(maturity) %>%
    filter_time(~.date)
}
```

```{r}
tidy_models <- function(.nested_models, .date) {
  coefs <- .nested_models %>%
    mutate(coef = map(model, tidy)) %>%
    unnest(coef) %>%
    select(maturity, term, estimate) %>%
    spread(term, estimate) %>%
    select(-`(Intercept)`)
  
  yield_fct <- yield_curve_factors %>%
    as_tbl_time(date) %>%
    filter_time(~.date)
  
  # Multiply the date's yield curve factors by the coefficients to get the
  # decomp of the term
  decomp <- coefs %>%
    mutate(level = level * yield_fct$level,
           slope = slope * yield_fct$slope,
           curvature = curvature * yield_fct$curvature)
  
  decomp
}
```

```{r}
tidy_decomposed_spot_rate <- function(.rates, .nested_models, .date) {
  .rates %>% 
    extract_rates(.date) %>% 
    left_join(tidy_models(.nested_models, .date), "maturity") %>%
    gather("line", "value", -(maturity:date)) %>%
    select(maturity, line, value)
}
```

What would these three functions work together to give? Well, for example, we can
try looking at January of 2012. For that date, we get the spot curve values along
with the level, slope and curvature components from each maturity's model.

```{r, warning=FALSE}
rates %>%
  tidy_decomposed_spot_rate(nested_models, "2012-01") %>%
  spread(line, value)
```

This extends naturally to charting the decomposed spot rate.

```{r}
# A charting function with custom themes
chart_decomposed_spot_rate <- function(.decomposed_spot) {
  .decomposed_spot %>%
    mutate(linetype = case_when(
      line == "spot_rate" ~ "a", # this works by alphabetical. first is solid, then dashed
      TRUE ~ "b"
    )) %>%
    ggplot(aes(x = maturity, y = value, color = line, linetype = linetype)) +
    geom_point() +
    geom_smooth(method = "loess", se = FALSE) +
    theme_minimal() +
    scale_color_brewer(palette = "Dark2") +
    labs(x = "Maturity", y = "Component Value", color = "Component") +
    guides(linetype = FALSE)
}
```


```{r, cache=TRUE, warning=FALSE, echo=FALSE, fig.width=10, fig.cap="Decomposed Spot Rate for January 2012"}
rates %>%
  tidy_decomposed_spot_rate(nested_models, "2012-01") %>%
  chart_decomposed_spot_rate()
```

The spot rate in January of 1981 was definitely an interesting time period! It's
essentially inverted, with lower maturity bonds having higher spot rates than
longer maturity bonds.

```{r, cache=TRUE, warning=FALSE, echo=FALSE, fig.width=10, fig.cap="Decomposed Spot Rate for January 1981"}
rates %>%
  tidy_decomposed_spot_rate(nested_models, "1981-01") %>%
  chart_decomposed_spot_rate()
```

## Coefficient Stability

Another question worth asking is how stable the coefficients are throughout time. We can test this by running the same regression as before, but with a _rolling window_. This works
by calculating the regression `spot_rate ~ level + slope + curvature` for the
first 100 days, then shift forward 1 day and drop the last day, calculate the
regression again, and repeat this for the length of the series. The `rsample`
package provides a number of helpers for doing analysis exactly like this.

First, let's split up our data into the rolling subsets. This results in an
extremely useful and compact format for our modeling purposes.

```{r}
all_splits <- spot_rates_q2 %>%
  # Add on the curve factors
  left_join(yield_curve_factors, by = "date") %>%
  group_by(maturity) %>%
  select(-maturity_nm) %>%
  nest() %>%
  # For each maturity, split the data into subsets of 100 data points
  mutate(data_splits = map(data, ~rolling_origin(.x, initial = 100, assess = 1, cumulative = FALSE)))

all_splits
```

If we were to dig into just 1 of the `data_splits` we would find another tibble
containing the slices. 

```{r}
all_splits$data_splits[[1]]
```

Each of the `rsplit` objects here contain all of the info needed to run the linear model
on that subset. We access that split's 100 data points with `analysis()`.

```{r}
analysis(all_splits$data_splits[[1]]$splits[[1]])
```

This notation might all look complicated, but it turns out to be incredibly useful
and scalable. To prove that, let's run the model on every split, for every maturity.

```{r, cache=TRUE}
plan(multiprocess)

all_splits <- all_splits %>%
  mutate(
    model_coef = future_map(data_splits, ~{ # For each maturity...
      
      maturity_splits <- .x
      
      map_dfr(maturity_splits$splits, ~ { # For each split...
        
        split.x <- .x
        date <- assessment(split.x)$date

        # Run the model
        mod <- lm(spot_rate ~ level + slope + curvature, data = analysis(split.x))

        # Tidy up
        tidy_mod <- mod %>% tidy()
        mutate(tidy_mod, date = date) %>%
          select(date, term, estimate)
      })
    })
  )

all_splits
```

We've just run `359 * 14 = 5026`  linear models. For me, it runs in parallel on
4 cores in ~8 seconds.

At this point, we can pick a maturity, and look at it's coefficients over time.
For example, the 1 year spot rate has fairly consistent model terms, but the
curvature has begun to rise up from `-0.5` to around `-0.25`. This change over time
isn't refected in the `-0.428` curvature estimate we get from running the model
over the full time period, and might offer other interesting insights.

```{r, echo=FALSE}
plot_coef_stability <- function(.x, .maturity) {
  coefs <- .x %>%
    filter(maturity == .maturity) %>%
    pull(model_coef) %>%
    pluck(1)
  
  coefs %>%
    mutate(term = as_factor(term)) %>%
    mutate(term = recode(term, `(Intercept)` = "Intercept", curvature = "Curvature", 
                         level = "Level", slope = "Slope")) %>%
    ggplot(aes(x = date, y = estimate)) +
    geom_line() +
    facet_wrap(~term) +
    labs(x = "", y = "Estimate") +
    theme_minimal()
}
```

```{r, fig.width=10, cache=TRUE, warning=FALSE, fig.cap="Coefficient stability for the 1 year spot rate using a 100 day rolling window", echo=FALSE}
plot_coef_stability(all_splits, 1) 
```

<br> </br>

The 5 year rate, on the other hand, shows the opposite result, with the curvature
term decreasing over time.

```{r, fig.width=10, cache=TRUE, warning=FALSE, fig.cap="Coefficient stability for the 5 year spot rate using a 100 day rolling window", echo=FALSE}
plot_coef_stability(all_splits, 5) 
```

<br> </br>

Finally, the 10 year shows a similar trend as the 1 year, but starts higher
initially.

```{r, fig.width=10, cache=TRUE, warning=FALSE, fig.cap="Coefficient stability for the 10 year spot rate using a 100 day rolling window", echo=FALSE}
plot_coef_stability(all_splits, 10) 
```

<br> </br>

## Do We Need All Three Factors?
